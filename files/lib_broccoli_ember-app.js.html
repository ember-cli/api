<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/broccoli/ember-app.js - ember-cli</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div class="yui3-g">
        <div id="sidebar" class="yui3-u">
            <div class="logo">
              <a href="../index.html">
                  <img src="https://ember-cli.com/assets/images/ember-cli-logo-small-dark.png">
              </a>
            </div>
            
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/ember-cli.html">ember-cli</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/Addon.html">Addon</a></li>
                            <li><a href="../classes/AddonDiscovery.html">AddonDiscovery</a></li>
                            <li><a href="../classes/AddonsFactory.html">AddonsFactory</a></li>
                            <li><a href="../classes/AmdTransformAddon.html">AmdTransformAddon</a></li>
                            <li><a href="../classes/Assembler.html">Assembler</a></li>
                            <li><a href="../classes/Blueprint.html">Blueprint</a></li>
                            <li><a href="../classes/Builder.html">Builder</a></li>
                            <li><a href="../classes/CLI.html">CLI</a></li>
                            <li><a href="../classes/Command.html">Command</a></li>
                            <li><a href="../classes/ConcatenationStrategy.html">ConcatenationStrategy</a></li>
                            <li><a href="../classes/EmberAddon.html">EmberAddon</a></li>
                            <li><a href="../classes/EmberApp.html">EmberApp</a></li>
                            <li><a href="../classes/HistorySupportAddon.html">HistorySupportAddon</a></li>
                            <li><a href="../classes/Instrumentation.html">Instrumentation</a></li>
                            <li><a href="../classes/NpmTask.html">NpmTask</a></li>
                            <li><a href="../classes/Project.html">Project</a></li>
                            <li><a href="../classes/ServeFilesAddon.html">ServeFilesAddon</a></li>
                            <li><a href="../classes/TestsServerAddon.html">TestsServerAddon</a></li>
                            <li><a href="../classes/WatcherAddon.html">WatcherAddon</a></li>
                            <li><a href="../classes/WindowsSymlinkChecker.html">WindowsSymlinkChecker</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div class="version-info">
              Version: 3.0.0--848ef37ffc
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><div class="title">
  <h1 class="file-name">lib/broccoli/ember-app.js</h1>
</div>

<pre class="code prettyprint linenums">
/* global require, module, escape */
&#x27;use strict&#x27;;

/**
@module ember-cli
*/
const fs = require(&#x27;fs&#x27;);
const existsSync = require(&#x27;exists-sync&#x27;);
const path = require(&#x27;path&#x27;);
const p = require(&#x27;ember-cli-preprocess-registry/preprocessors&#x27;);
const chalk = require(&#x27;chalk&#x27;);
const resolve = require(&#x27;resolve&#x27;);

const Project = require(&#x27;../models/project&#x27;);
const cleanBaseURL = require(&#x27;clean-base-url&#x27;);
const SilentError = require(&#x27;silent-error&#x27;);

let preprocessJs = p.preprocessJs;
let preprocessCss = p.preprocessCss;
let isType = p.isType;

let preprocessTemplates = p.preprocessTemplates;

let preprocessMinifyCss = p.preprocessMinifyCss;

const concat = require(&#x27;broccoli-concat&#x27;);

const ConfigReplace = require(&#x27;broccoli-config-replace&#x27;);
const ConfigLoader = require(&#x27;broccoli-config-loader&#x27;);
const mergeTrees = require(&#x27;./merge-trees&#x27;);
const WatchedDir = require(&#x27;broccoli-source&#x27;).WatchedDir;
const UnwatchedDir = require(&#x27;broccoli-source&#x27;).UnwatchedDir;

const merge = require(&#x27;ember-cli-lodash-subset&#x27;).merge;
const defaultsDeep = require(&#x27;ember-cli-lodash-subset&#x27;).defaultsDeep;
const omitBy = require(&#x27;ember-cli-lodash-subset&#x27;).omitBy;
const isNull = require(&#x27;ember-cli-lodash-subset&#x27;).isNull;
const Funnel = require(&#x27;broccoli-funnel&#x27;);
const funnelReducer = require(&#x27;broccoli-funnel-reducer&#x27;);
const logger = require(&#x27;heimdalljs-logger&#x27;)(&#x27;ember-cli:ember-app&#x27;);
const addonProcessTree = require(&#x27;../utilities/addon-process-tree&#x27;);
const lintAddonsByType = require(&#x27;../utilities/lint-addons-by-type&#x27;);
const experiments = require(&#x27;../experiments&#x27;);
const processModulesOnly = require(&#x27;./babel-process-modules-only&#x27;);
const semver = require(&#x27;semver&#x27;);
const Assembler = require(&#x27;./assembler&#x27;);
const strategies = require(&#x27;./strategies&#x27;);

const createVendorJsStrategy = strategies.createVendorJsStrategy;
const createApplicationJsStrategy = strategies.createApplicationJsStrategy;

let DEFAULT_CONFIG = {
  storeConfigInMeta: true,
  autoRun: true,
  outputPaths: {
    app: {
      html: &#x27;index.html&#x27;,
    },
    tests: {
      js: &#x27;/assets/tests.js&#x27;,
    },
    vendor: {
      css: &#x27;/assets/vendor.css&#x27;,
      js: &#x27;/assets/vendor.js&#x27;,
    },
    testSupport: {
      css: &#x27;/assets/test-support.css&#x27;,
      js: {
        testSupport: &#x27;/assets/test-support.js&#x27;,
        testLoader: &#x27;/assets/test-loader.js&#x27;,
      },
    },
  },
  minifyCSS: {
    options: { relativeTo: &#x27;assets&#x27; },
  },
  sourcemaps: {},
  trees: {},
  jshintrc: {},
  addons: {},
};

function needsEmberCLIShims(addons) {
  let babelInstance = addons.find(addon =&gt; addon.name === &#x27;ember-cli-babel&#x27;);
  if (!babelInstance) {
    return false;
  }

  let version = babelInstance.pkg.version;
  if (semver.lt(version, &#x27;6.6.0&#x27;)) {
    return true;
  }

  return addons.some(addon =&gt; needsEmberCLIShims(addon.addons));
}

class EmberApp {
  /**
   EmberApp is the main class Ember CLI uses to manage the Broccoli trees
   for your application. It is very tightly integrated with Broccoli and has
   a &#x60;toTree()&#x60; method you can use to get the entire tree for your application.

   Available init options:
   - storeConfigInMeta, defaults to &#x60;true&#x60;
   - autoRun, defaults to &#x60;true&#x60;
   - outputPaths, defaults to &#x60;{}&#x60;
   - minifyCSS, defaults to &#x60;{enabled: !!isProduction,options: { relativeTo: &#x27;assets&#x27; }}
   - minifyJS, defaults to &#x60;{enabled: !!isProduction}
   - sourcemaps, defaults to &#x60;{}&#x60;
   - trees, defaults to &#x60;{}&#x60;
   - jshintrc, defaults to &#x60;{}&#x60;
   - vendorFiles, defaults to &#x60;{}&#x60;
   - addons, defaults to &#x60;{ blacklist: [], whitelist: [] }&#x60;

   @class EmberApp
   @constructor
   @param {Object} [defaults]
   @param {Object} [options={}] Configuration options
   */
  constructor(defaults, options) {
    if (arguments.length === 0) {
      options = {};
    } else if (arguments.length === 1) {
      options = defaults;
    } else {
      defaultsDeep(options, defaults);
    }

    this._initProject(options);
    this.name = options.name || this.project.name();

    this.env = EmberApp.env();
    this.isProduction = (this.env === &#x27;production&#x27;);

    this.registry = options.registry || p.defaultRegistry(this);

    this.bowerDirectory = this.project.bowerDirectory;

    this._initTestsAndHinting(options);
    this._initOptions(options);
    this._initVendorFiles();

    this._styleOutputFiles = { };

    // ensure addon.css always gets concated
    this._styleOutputFiles[this.options.outputPaths.vendor.css] = [];


    this._scriptOutputFiles = {};
    this._customTransformsMap = new Map();

    this.otherAssetPaths = [];
    this.legacyTestFilesToAppend = [];
    this.vendorTestStaticStyles = [];
    this._nodeModules = new Map();

    this.trees = this.options.trees;

    this.populateLegacyFiles();
    this.initializeAddons();
    this.project.addons.forEach(addon =&gt; addon.app = this);
    p.setupRegistry(this);
    this._importAddonTransforms();
    this._notifyAddonIncluded();

    if (!this._addonInstalled(&#x27;loader.js&#x27;) &amp;&amp; !this.options._ignoreMissingLoader) {
      throw new SilentError(&#x27;The loader.js addon is missing from your project, please add it to &#x60;package.json&#x60;.&#x27;);
    }
  }

  /**
    Initializes the &#x60;tests&#x60; and &#x60;hinting&#x60; properties.

    Defaults to &#x60;false&#x60; unless &#x60;ember test&#x60; was used or this is *not* a production build.

    @private
    @method _initTestsAndHinting
    @param {Object} options
  */
  _initTestsAndHinting(options) {
    let testsEnabledDefault = process.env.EMBER_CLI_TEST_COMMAND || !this.isProduction;

    this.tests = options.hasOwnProperty(&#x27;tests&#x27;) ? options.tests : testsEnabledDefault;
    this.hinting = options.hasOwnProperty(&#x27;hinting&#x27;) ? options.hinting : testsEnabledDefault;
  }

  /**
    Initializes the &#x60;project&#x60; property from &#x60;options.project&#x60; or the
    closest Ember CLI project from the current working directory.

    @private
    @method _initProject
    @param {Object} options
  */
  _initProject(options) {
    let app = this;

    this.project = options.project || Project.closestSync(process.cwd());

    if (options.configPath) {
      this.project.configPath = function() { return app._resolveLocal(options.configPath); };
    }
  }

  /**
    Initializes the &#x60;options&#x60; property from the &#x60;options&#x60; parameter and
    a set of default values from Ember CLI.

    @private
    @method _initOptions
    @param {Object} options
  */
  _initOptions(options) {
    let srcPath = this._resolveLocal(&#x27;src&#x27;);
    let srcTree = existsSync(srcPath) ? new WatchedDir(srcPath) : null;

    let appPath = this._resolveLocal(&#x27;app&#x27;);
    let appTree;
    if (experiments.MODULE_UNIFICATION) {
      appTree = existsSync(appPath) ? new WatchedDir(appPath) : null;
    } else {
      appTree = new WatchedDir(appPath);
    }

    let testsPath = this._resolveLocal(&#x27;tests&#x27;);
    let testsTree = existsSync(testsPath) ? new WatchedDir(testsPath) : null;

    // these are contained within app/ no need to watch again
    // (we should probably have the builder or the watcher dedup though)

    if (experiments.MODULE_UNIFICATION) {
      let srcStylesPath = this._resolveLocal(&#x27;src/ui/styles&#x27;);
      this._stylesPath = existsSync(srcStylesPath) ? srcStylesPath : this._resolveLocal(&#x27;app/styles&#x27;);
    } else {
      this._stylesPath = this._resolveLocal(&#x27;app/styles&#x27;);
    }
    let stylesTree = new UnwatchedDir(this._stylesPath);

    let templatesPath = this._resolveLocal(&#x27;app/templates&#x27;);
    let templatesTree = existsSync(templatesPath) ? new UnwatchedDir(templatesPath) : null;

    // do not watch bower&#x27;s default directory by default
    let bowerDirectory = this._resolveLocal(this.bowerDirectory);
    let bowerTree = this.project._watchmanInfo.enabled ? bowerDirectory : new UnwatchedDir(bowerDirectory);

    let vendorPath = this._resolveLocal(&#x27;vendor&#x27;);
    let vendorTree = existsSync(vendorPath) ? new WatchedDir(vendorPath) : null;

    let publicPath = this._resolveLocal(&#x27;public&#x27;);
    let publicTree = existsSync(publicPath) ? new WatchedDir(publicPath) : null;

    let detectedDefaultOptions = {
      babel: { },
      jshintrc: {
        app: this.project.root,
        tests: testsPath,
      },
      minifyCSS: {
        enabled: this.isProduction,
        options: { processImport: false },
      },
      minifyJS: {
        enabled: this.isProduction,
        options: {
          compress: {
            // this is adversely affects heuristics for IIFE eval
            &#x27;negate_iife&#x27;: false,
            // limit sequences because of memory issues during parsing
            sequences: 30,
          },
          output: {
            // no difference in size and much easier to debug
            semicolons: false,
          },
        },
      },
      outputPaths: {
        app: {
          css: {
            &#x27;app&#x27;: &#x60;/assets/${this.name}.css&#x60;,
          },
          js: &#x60;/assets/${this.name}.js&#x60;,
        },
      },
      sourcemaps: {
        enabled: !this.isProduction,
        extensions: [&#x27;js&#x27;],
      },
      trees: {
        src: srcTree,
        app: appTree,
        tests: testsTree,
        styles: stylesTree,
        templates: templatesTree,
        bower: bowerTree,
        vendor: vendorTree,
        public: publicTree,
      },
    };

    let emberCLIBabelInstance = this.project.findAddonByName(&#x27;ember-cli-babel&#x27;);
    if (emberCLIBabelInstance) {
      let version = this.project.require(&#x27;ember-cli-babel/package.json&#x27;).version;
      if (semver.lt(version, &#x27;6.0.0-alpha.1&#x27;)) {
        detectedDefaultOptions.babel = {
          modules: &#x27;amdStrict&#x27;,
          moduleIds: true,
          resolveModuleSource: require(&#x27;amd-name-resolver&#x27;).moduleResolve,
        };
      }

      // future versions of ember-cli-babel will be moving the location for its
      // own configuration options out of &#x60;babel&#x60; and will be issuing a deprecation
      // if used in the older way
      //
      // see: https://github.com/babel/ember-cli-babel/pull/105
      let emberCLIBabelConfigKey = emberCLIBabelInstance.configKey || &#x27;babel&#x27;;
      detectedDefaultOptions[emberCLIBabelConfigKey] = detectedDefaultOptions[emberCLIBabelConfigKey] || {};
      detectedDefaultOptions[emberCLIBabelConfigKey].compileModules = true;
    }

    this.options = defaultsDeep(options, detectedDefaultOptions, DEFAULT_CONFIG);

    // For now we must disable Babel sourcemaps due to unforeseen
    // performance regressions.
    if (!(&#x27;sourceMaps&#x27; in this.options.babel)) {
      this.options.babel.sourceMaps = false;
    }
  }

  /**
    Resolves a path relative to the project&#x27;s root

    @private
    @method _resolveLocal
  */
  _resolveLocal(to) {
    return path.join(this.project.root, to);
  }

  /**
    @private
    @method _initVendorFiles
  */
  _initVendorFiles() {
    let bowerDeps = this.project.bowerDependencies();
    let ember = this.project.findAddonByName(&#x27;ember-source&#x27;);
    let addonEmberCliShims = this.project.findAddonByName(&#x27;ember-cli-shims&#x27;);
    let bowerEmberCliShims = bowerDeps[&#x27;ember-cli-shims&#x27;];
    let developmentEmber;
    let productionEmber;
    let emberTesting;
    let emberShims = null;
    let jquery;

    if (ember) {
      developmentEmber = ember.paths.debug;
      productionEmber = ember.paths.prod;
      emberTesting = ember.paths.testing;
      emberShims = ember.paths.shims;
      jquery = ember.paths.jquery;
    } else {
      jquery = &#x60;${this.bowerDirectory}/jquery/dist/jquery.js&#x60;;

      if (bowerEmberCliShims) {
        emberShims = &#x60;${this.bowerDirectory}/ember-cli-shims/app-shims.js&#x60;;
      }

      // in Ember 1.10 and higher &#x60;ember.js&#x60; is deprecated in favor of
      // the more aptly named &#x60;ember.debug.js&#x60;.
      productionEmber = &#x60;${this.bowerDirectory}/ember/ember.prod.js&#x60;;
      developmentEmber = &#x60;${this.bowerDirectory}/ember/ember.debug.js&#x60;;
      if (!existsSync(this._resolveLocal(developmentEmber))) {
        developmentEmber = &#x60;${this.bowerDirectory}/ember/ember.js&#x60;;
      }
      emberTesting = &#x60;${this.bowerDirectory}/ember/ember-testing.js&#x60;;
    }

    let handlebarsVendorFiles;
    if (&#x27;handlebars&#x27; in bowerDeps) {
      handlebarsVendorFiles = {
        development: &#x60;${this.bowerDirectory}/handlebars/handlebars.js&#x60;,
        production: &#x60;${this.bowerDirectory}/handlebars/handlebars.runtime.js&#x60;,
      };
    } else {
      handlebarsVendorFiles = null;
    }

    this.vendorFiles = omitBy(merge({
      &#x27;jquery.js&#x27;: jquery,
      &#x27;handlebars.js&#x27;: handlebarsVendorFiles,
      &#x27;ember.js&#x27;: {
        development: developmentEmber,
        production: productionEmber,
      },
      &#x27;ember-testing.js&#x27;: [
        emberTesting,
        { type: &#x27;test&#x27; },
      ],
      &#x27;app-shims.js&#x27;: emberShims,
      &#x27;ember-resolver.js&#x27;: [
        &#x60;${this.bowerDirectory}/ember-resolver/dist/modules/ember-resolver.js&#x60;, {
          exports: {
            &#x27;ember/resolver&#x27;: [&#x27;default&#x27;],
          },
        },
      ],
    }, this.options.vendorFiles), isNull);

    if (this._addonInstalled(&#x27;ember-resolver&#x27;) || !bowerDeps[&#x27;ember-resolver&#x27;]) {
      // if the project is using &#x60;ember-resolver&#x60; as an addon
      // remove it from &#x60;vendorFiles&#x60; (the npm version properly works
      // without &#x60;app.import&#x60;s)
      delete this.vendorFiles[&#x27;ember-resolver.js&#x27;];
    }

    // Warn if ember-cli-shims is not included.
    // certain versions of &#x60;ember-source&#x60; bundle them by default,
    // so we must check if that is the load mechanism of ember
    // before checking &#x60;bower&#x60;.
    if (!emberShims &amp;&amp; !addonEmberCliShims &amp;&amp; !bowerEmberCliShims &amp;&amp; needsEmberCLIShims(this.project.addons)) {
      this.project.ui.writeWarnLine(&#x27;You have not included &#x60;ember-cli-shims&#x60; in your project\&#x27;s &#x60;bower.json&#x60; or &#x60;package.json&#x60;. This only works if you provide an alternative yourself and unset &#x60;app.vendorFiles[\&#x27;app-shims.js\&#x27;]&#x60;.&#x27;);
    }

    // If ember-testing.js is coming from Bower (not ember-source) and it does not
    // exist, then we remove it from vendor files. This is needed to support versions
    // of Ember older than 1.8.0 (when ember-testing.js was incldued in ember.js itself)
    if (!ember &amp;&amp; this.vendorFiles[&#x27;ember-testing.js&#x27;] &amp;&amp; !existsSync(this.vendorFiles[&#x27;ember-testing.js&#x27;][0])) {
      delete this.vendorFiles[&#x27;ember-testing.js&#x27;];
    }
  }

  /**
    Returns the environment name

    @public
    @static
    @method env
    @return {String} Environment name
   */
  static env() {
    return process.env.EMBER_ENV || &#x27;development&#x27;;
  }

  /**
    Delegates to &#x60;broccoli-concat&#x60; with the &#x60;sourceMapConfig&#x60; option set to &#x60;options.sourcemaps&#x60;.

    @private
    @method _concatFiles
    @param tree
    @param options
    @return
  */
  _concatFiles(tree, options) {
    options.sourceMapConfig = this.options.sourcemaps;

    return concat(tree, options);
  }

  /**
    Checks the result of &#x60;addon.isEnabled()&#x60; if it exists, defaults to &#x60;true&#x60; otherwise.

    @private
    @method _addonEnabled
    @param {Addon} addon
    @return {Boolean}
  */
  _addonEnabled(addon) {
    return !addon.isEnabled || addon.isEnabled();
  }

  /**
    @private
    @method _addonDisabledByBlacklist
    @param {Addon} addon
    @return {Boolean}
  */
  _addonDisabledByBlacklist(addon) {
    let blacklist = this.options.addons.blacklist;
    return !!blacklist &amp;&amp; blacklist.indexOf(addon.name) !== -1;
  }

  /**
    @private
    @method _addonDisabledByWhitelist
    @param {Addon} addon
    @return {Boolean}
  */
  _addonDisabledByWhitelist(addon) {
    let whitelist = this.options.addons.whitelist;
    return !!whitelist &amp;&amp; whitelist.indexOf(addon.name) === -1;
  }

  /**
    Returns whether an addon should be added to the project

    @private
    @method shouldIncludeAddon
    @param {Addon} addon
    @return {Boolean}
  */
  shouldIncludeAddon(addon) {
    if (!this._addonEnabled(addon)) {
      return false;
    }

    return !this._addonDisabledByBlacklist(addon) &amp;&amp; !this._addonDisabledByWhitelist(addon);
  }

  /**
    Calls the included hook on addons.

    @private
    @method _notifyAddonIncluded
  */
  _notifyAddonIncluded() {
    let addonNames = this.project.addons.map(addon =&gt; addon.name);

    if (this.options.addons.blacklist) {
      this.options.addons.blacklist.forEach(addonName =&gt; {
        if (addonNames.indexOf(addonName) === -1) {
          throw new Error(&#x60;Addon &quot;${addonName}&quot; defined in blacklist is not found&#x60;);
        }
      });
    }

    if (this.options.addons.whitelist) {
      this.options.addons.whitelist.forEach(addonName =&gt; {
        if (addonNames.indexOf(addonName) === -1) {
          throw new Error(&#x60;Addon &quot;${addonName}&quot; defined in whitelist is not found&#x60;);
        }
      });
    }

    this.project.addons = this.project.addons.filter(addon =&gt; {
      if (this.shouldIncludeAddon(addon)) {
        if (addon.included) {
          addon.included(this);
        }

        return addon;
      }
    });
  }

  /**
    Calls the importTransforms hook on addons.

    @private
    @method _importAddonTransforms
  */
  _importAddonTransforms() {
    this.project.addons.forEach(addon =&gt; {
      if (this.shouldIncludeAddon(addon)) {
        if (addon.importTransforms) {
          let transforms = addon.importTransforms();

          if (!transforms) {
            throw new Error(&#x60;Addon &quot;${addon.name}&quot; did not return a transform map from importTransforms function&#x60;);
          }

          Object.keys(transforms).forEach(transformName =&gt; {
            let transformConfig = {
              files: [],
              options: {},
            };

            // store the transform info
            if (typeof transforms[transformName] === &#x27;object&#x27;) {
              transformConfig[&#x27;callback&#x27;] = transforms[transformName].transform;
              transformConfig[&#x27;processOptions&#x27;] = transforms[transformName].processOptions;
            } else if (typeof transforms[transformName] === &#x27;function&#x27;) {
              transformConfig[&#x27;callback&#x27;] = transforms[transformName];
              transformConfig[&#x27;processOptions&#x27;] = (assetPath, entry, options) =&gt; options;
            } else {
              throw new Error(&#x60;Addon &quot;${addon.name}&quot; did not return a callback function correctly for transform &quot;${transformName}&quot;.&#x60;);
            }

            if (this._customTransformsMap.has(transformName)) {
              // there is already a transform with a same name, therefore we warn the user
              this.project.ui.writeWarnLine(&#x60;Addon &quot;${addon.name}&quot; is defining a transform name: ${transformName} that is already being defined. Using transform from addon: &quot;${addon.name}&quot;.&#x60;);
            }

            this._customTransformsMap.set(transformName, transformConfig);
          });
        }
      }
    });
  }

  /**
    Loads and initializes addons for this project.
    Calls initializeAddons on the Project.

    @private
    @method initializeAddons
  */
  initializeAddons() {
    this.project.initializeAddons();
  }

  /**
    Returns a list of trees for a given type, returned by all addons.

    @private
    @method addonTreesFor
    @param  {String} type Type of tree
    @return {Array}       List of trees
   */
  addonTreesFor(type) {
    return this.project.addons.reduce((sum, addon) =&gt; {
      if (addon.treeFor) {
        let val = addon.treeFor(type);
        if (val) { sum.push(val); }
      }
      return sum;
    }, []);
  }

  /**
    Runs addon post-processing on a given tree and returns the processed tree.

    This enables addons to do process immediately **after** the preprocessor for a
    given type is run, but before concatenation occurs. If an addon wishes to
    apply a transform before the preprocessors run, they can instead implement the
    preprocessTree hook.

    To utilize this addons implement &#x60;postprocessTree&#x60; hook.

    An example, would be to apply some broccoli transform on all JS files, but
    only after the existing pre-processors have run.

    &#x60;&#x60;&#x60;js
    module.exports = {
      name: &#x27;my-cool-addon&#x27;,
      postprocessTree(type, tree) {
        if (type === &#x27;js&#x27;) {
          return someBroccoliTransform(tree);
        }

        return tree;
      }
    }

    &#x60;&#x60;&#x60;

    @private
    @method addonPostprocessTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonPostprocessTree(type, tree) {
    return addonProcessTree(this.project, &#x27;postprocessTree&#x27;, type, tree);
  }


  /**
    Runs addon pre-processing on a given tree and returns the processed tree.

    This enables addons to do process immediately **before** the preprocessor for a
    given type is run.  If an addon wishes to apply a transform  after the
    preprocessors run, they can instead implement the postprocessTree hook.

    To utilize this addons implement &#x60;preprocessTree&#x60; hook.

    An example, would be to remove some set of files before the preprocessors run.

    &#x60;&#x60;&#x60;js
    var stew = require(&#x27;broccoli-stew&#x27;);

    module.exports = {
      name: &#x27;my-cool-addon&#x27;,
      preprocessTree(type, tree) {
        if (type === &#x27;js&#x27; &amp;&amp; type === &#x27;template&#x27;) {
          return stew.rm(tree, someGlobPattern);
        }

        return tree;
      }
    }
    &#x60;&#x60;&#x60;

    @private
    @method addonPreprocessTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonPreprocessTree(type, tree) {
    return addonProcessTree(this.project, &#x27;preprocessTree&#x27;, type, tree);
  }

  /**
    Runs addon lintTree hooks and returns a single tree containing all
    their output.

    @private
    @method addonLintTree
    @param  {String} type Type of tree
    @param  {Tree}   tree Tree to process
    @return {Tree}        Processed tree
   */
  addonLintTree(type, tree) {
    let output = lintAddonsByType(this.project.addons, type, tree);

    return mergeTrees(output, {
      overwrite: true,
      annotation: &#x60;TreeMerger (lint ${type})&#x60;,
    });
  }

  /**
    Imports legacy imports in this.vendorFiles

    @private
    @method populateLegacyFiles
  */
  populateLegacyFiles() {
    let name;
    for (name in this.vendorFiles) {
      let args = this.vendorFiles[name];

      if (args === null) { continue; }

      this.import.apply(this, [].concat(args));
    }
  }

  /**
    Returns the tree for app/index.html

    @private
    @method index
    @return {Tree} Tree for app/index.html
  */
  index() {
    let htmlName = this.options.outputPaths.app.html;

    let index;
    if (!experiments.MODULE_UNIFICATION || !this.trees.src) {
      index = this._rawAppIndex(htmlName);
    } else {
      let appIndex = this._rawAppIndex(htmlName, true);
      let srcIndex = this._rawSrcIndex(htmlName);
      index = mergeTrees([appIndex, srcIndex], { overwrite: true });
    }

    return new ConfigReplace(index, this._configTree(), {
      configPath: path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;${this.env}.json&#x60;),
      files: [htmlName],
      patterns: this._configReplacePatterns(),
    });
  }

  _rawAppIndex(outputPath, optional) {
    if (!this.trees.app) { return; }

    return new Funnel(this.trees.app, {
      [optional ? &#x27;include&#x27; : &#x27;files&#x27;]: [&#x27;index.html&#x27;],
      getDestinationPath: () =&gt; outputPath,
      annotation: &#x27;Funnel: index.html&#x27;,
    });
  }

  _rawSrcIndex(outputPath) {
    return new Funnel(this.trees.src, {
      files: [&#x27;ui/index.html&#x27;],
      getDestinationPath: () =&gt; outputPath,
      annotation: &#x27;Funnel: index.html&#x27;,
    });
  }

  /**
    Filters styles and templates from the &#x60;app&#x60; tree.

    @private
    @method _filterAppTree
    @return {Tree}
  */
  _filterAppTree() {
    if (!this.trees.app) {
      return;
    }

    if (!this._cachedFilterAppTree) {
      let podPatterns = this._podTemplatePatterns();
      let excludePatterns = podPatterns.concat([
        // note: do not use path.sep here Funnel uses
        // walk-sync which always joins with &#x60;/&#x60; (not path.sep)
        &#x27;styles/**/*&#x27;,
        &#x27;templates/**/*&#x27;,
      ]);

      this._cachedFilterAppTree = new Funnel(this.trees.app, {
        exclude: excludePatterns,
        annotation: &#x27;Funnel: Filtered App&#x27;,
      });
    }

    return this._cachedFilterAppTree;
  }

  podTemplates() {
    return new Funnel(this.trees.app, {
      include: this._podTemplatePatterns(),
      exclude: [&#x27;templates/**/*&#x27;],
      destDir: &#x60;${this.name}/&#x60;,
      annotation: &#x27;Funnel: Pod Templates&#x27;,
    });
  }

  _templatesTree() {
    if (!this._cachedTemplateTree) {
      let trees = [];
      if (this.trees.templates) {
        let standardTemplates = new Funnel(this.trees.templates, {
          srcDir: &#x27;/&#x27;,
          destDir: &#x60;${this.name}/templates&#x60;,
          annotation: &#x27;Funnel: Templates&#x27;,
        });

        trees.push(standardTemplates);
      }

      if (this.trees.app) {
        trees.push(this.podTemplates());
      }

      this._cachedTemplateTree = mergeTrees(trees, {
        annotation: &#x27;TreeMerge (templates)&#x27;,
      });
    }

    return this._cachedTemplateTree;
  }

  /**
    @private
    @method _configReplacePatterns
    @return
  */
  _configReplacePatterns() {
    return [{
      match: /{{rootURL}}/g,
      replacement: calculateRootURL,
    }, {
      match: /{{EMBER_ENV}}/g,
      replacement: calculateEmberENV,
    }, {
      match: /{{content-for [&#x27;&quot;](.+)[&quot;&#x27;]}}/g,
      replacement: this.contentFor.bind(this),
    }, {
      match: /{{MODULE_PREFIX}}/g,
      replacement: calculateModulePrefix,
    }];
  }

  /**
    Returns the tree for /tests/index.html

    @private
    @method testIndex
    @return {Tree} Tree for /tests/index.html
   */
  testIndex() {
    let index = new Funnel(this.trees.tests, {
      srcDir: &#x27;/&#x27;,
      files: [&#x27;index.html&#x27;],
      destDir: &#x27;/tests&#x27;,
      annotation: &#x27;Funnel (test index)&#x27;,
    });

    return new ConfigReplace(index, this._configTree(), {
      configPath: path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x27;test.json&#x27;),
      files: [&#x27;tests/index.html&#x27;],
      env: &#x27;test&#x27;,
      patterns: this._configReplacePatterns(),
    });
  }

  /**
    Returns the tree for /public

    @private
    @method publicTree
    @return {Tree} Tree for /public
   */
  publicTree() {
    let trees = this.addonTreesFor(&#x27;public&#x27;);

    if (this.trees.public) {
      trees.push(this.trees.public);
    }

    return mergeTrees(trees, {
      overwrite: true,
      annotation: &#x27;TreeMerge (public)&#x27;,
    });
  }


  /**
    @private
    @method _processedAppTree
    @return
  */
  _processedAppTree() {
    let appTrees = [].concat(
      this.addonTreesFor(&#x27;app&#x27;),
      this._filterAppTree()
    ).filter(Boolean);

    let mergedApp = mergeTrees(appTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (app)&#x27;,
    });

    return new Funnel(mergedApp, {
      srcDir: &#x27;/&#x27;,
      destDir: this.name,
      annotation: &#x27;ProcessedAppTree&#x27;,
    });
  }

  /**
    @private
    @method _processedSrcTree
    @return
  */
  _processedSrcTree() {
    if (!experiments.MODULE_UNIFICATION) {
      return null;
    }
    // styles
    // templates
    let rawSrcTree = this.trees.src;

    if (!rawSrcTree) { return; }

    let srcNamespacedTree = new Funnel(rawSrcTree, {
      destDir: &#x27;src&#x27;,
    });

    let srcAfterPreprocessTreeHook = this.addonPreprocessTree(&#x27;src&#x27;, srcNamespacedTree);

    let options = {
      outputPaths: this.options.outputPaths.app.css,
      registry: this.registry,
    };

    // TODO: This isn&#x27;t quite correct (but it does function properly in most cases),
    // and should be re-evaluated before enabling the &#x60;MODULE_UNIFICATION&#x60; feature
    this._srcAfterStylePreprocessing = preprocessCss(srcAfterPreprocessTreeHook, &#x27;/src/ui/styles&#x27;, &#x27;/assets&#x27;, options);

    let srcAfterTemplatePreprocessing = preprocessTemplates(srcAfterPreprocessTreeHook, {
      registry: this.registry,
      annotation: &#x27;Process Templates: src&#x27;,
    });

    let srcAfterPostprocessTreeHook = this.addonPostprocessTree(&#x27;src&#x27;, srcAfterTemplatePreprocessing);

    return new Funnel(srcAfterPostprocessTreeHook, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}&#x60;,
      annotation: &#x27;Funnel: src&#x27;,
    });
  }

  /**
    @private
    @method _processedTemplatesTree
    @return
  */
  _processedTemplatesTree() {
    let addonTrees = this.addonTreesFor(&#x27;templates&#x27;);
    let mergedTemplates = mergeTrees(addonTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (templates)&#x27;,
    });

    let addonTemplates = new Funnel(mergedTemplates, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}/templates&#x60;,
      annotation: &#x27;ProcessedTemplateTree&#x27;,
    });

    let combinedTemplates = mergeTrees([
      addonTemplates,
      this._templatesTree(),
    ], {
      annotation: &#x27;addonPreprocessTree(template)&#x27;,
      overwrite: true,
    });

    let templates = this.addonPreprocessTree(&#x27;template&#x27;, combinedTemplates);

    return this.addonPostprocessTree(&#x27;template&#x27;, preprocessTemplates(templates, {
      registry: this.registry,
      annotation: &#x27;TreeMerger (pod &amp; standard templates)&#x27;,
    }));
  }

  /**
    @private
    @method _podTemplatePatterns
    @return {Array} An array of regular expressions.
  */
  _podTemplatePatterns() {
    return this.registry.extensionsForType(&#x27;template&#x27;)
      .map(extension =&gt; &#x60;**/*/template.${extension}&#x60;);
  }

  /**
    @private
    @method _processedTestsTree
    @return
  */
  _processedTestsTree() {
    let addonTrees = this.addonTreesFor(&#x27;test-support&#x27;);
    let mergedTests = mergeTrees(addonTrees.concat(this.trees.tests), {
      overwrite: true,
      annotation: &#x27;TreeMerger (tests)&#x27;,
    });

    return new Funnel(mergedTests, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}/tests&#x60;,
      annotation: &#x27;ProcessedTestTree&#x27;,
    });
  }

  /**
    @private
    @method _processedBowerTree
    @return
  */
  _processedBowerTree() {
    if (!this._cachedBowerTree) {
      // do not attempt to merge bower and vendor together
      // if they are the same tree
      if (this.bowerDirectory === &#x27;vendor&#x27;) {
        return;
      }

      // Don&#x27;t blow up if there is no bower_components folder.
      if (!existsSync(this.bowerDirectory)) {
        return;
      }

      this._cachedBowerTree = new Funnel(this.trees.bower, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x60;${this.bowerDirectory}/&#x60;,
        annotation: &#x27;Funnel (bower)&#x27;,
      });
    }

    return this._cachedBowerTree;
  }

  _nodeModuleTrees() {
    if (!this._cachedNodeModuleTrees) {
      this._cachedNodeModuleTrees = Array.from(this._nodeModules.values(), module =&gt; new Funnel(module.path, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x60;node_modules/${module.name}/&#x60;,
        annotation: &#x60;Funnel (node_modules/${module.name})&#x60;,
      }));
    }

    return this._cachedNodeModuleTrees;
  }

  _addonTree() {
    if (!this._cachedAddonTree) {
      let addonTrees = this.addonTreesFor(&#x27;addon&#x27;);

      let combinedAddonTree = mergeTrees(addonTrees, {
        overwrite: true,
        annotation: &#x27;TreeMerger: &#x60;addon/&#x60; trees&#x27;,
      });

      this._cachedAddonTree = new Funnel(combinedAddonTree, {
        destDir: &#x27;addon-tree-output&#x27;,
        annotation: &#x27;Funnel: addon-tree-output&#x27;,
      });
    }

    return this._cachedAddonTree;
  }

  /**
    @private
    @method _processedVendorTree
    @return
  */
  _processedVendorTree() {
    if (!this._cachedVendorTree) {
      let trees = this.addonTreesFor(&#x27;vendor&#x27;);

      if (this.trees.vendor) {
        trees.push(this.trees.vendor);
      }

      let mergedVendor = mergeTrees(trees, {
        overwrite: true,
        annotation: &#x27;TreeMerger (vendor)&#x27;,
      });

      this._cachedVendorTree = new Funnel(mergedVendor, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x27;vendor/&#x27;,
        annotation: &#x27;Funnel (vendor)&#x27;,
      });
    }

    return this._cachedVendorTree;
  }

  /**
    @private
    @method _processedExternalTree
    @return
  */
  _processedExternalTree() {
    if (!this._cachedExternalTree) {
      let vendor = this._processedVendorTree();
      let bower = this._processedBowerTree();
      let addons = this._addonTree();

      let trees = [vendor].concat(addons);
      if (bower) {
        trees.unshift(bower);
      }

      trees = this._nodeModuleTrees().concat(trees);

      let externalTree = mergeTrees(trees, {
        annotation: &#x27;TreeMerger (ExternalTree)&#x27;,
        overwrite: true,
      });

      for (let customTransformEntry of this._customTransformsMap) {
        let transformName = customTransformEntry[0];
        let transformConfig = customTransformEntry[1];

        let transformTree = new Funnel(externalTree, {
          files: transformConfig.files,
          annotation: &#x60;Funnel (custom transform: ${transformName})&#x60;,
        });

        externalTree = mergeTrees([externalTree, transformConfig.callback(transformTree, transformConfig.options)], {
          annotation: &#x60;TreeMerger (custom transform: ${transformName})&#x60;,
          overwrite: true,
        });
      }

      this._cachedExternalTree = externalTree;
    }

    return this._cachedExternalTree;
  }

  /**
    @private
    @method _configTree
    @return
  */
  _configTree() {
    if (!this._cachedConfigTree) {
      let configPath = this.project.configPath();
      let configTree = new ConfigLoader(path.dirname(configPath), {
        env: this.env,
        tests: this.tests,
        project: this.project,
      });

      this._cachedConfigTree = new Funnel(configTree, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x60;${this.name}/config&#x60;,
        annotation: &#x27;Funnel (config)&#x27;,
      });
    }

    return this._cachedConfigTree;
  }

  /**
    @private
    @method _processedEmberCLITree
    @return
  */
  _processedEmberCLITree() {
    if (!this._cachedEmberCLITree) {
      let files = [
        &#x27;vendor-prefix.js&#x27;,
        &#x27;vendor-suffix.js&#x27;,
        &#x27;app-prefix.js&#x27;,
        &#x27;app-suffix.js&#x27;,
        &#x27;app-config.js&#x27;,
        &#x27;app-boot.js&#x27;,
        &#x27;test-support-prefix.js&#x27;,
        &#x27;test-support-suffix.js&#x27;,
        &#x27;tests-prefix.js&#x27;,
        &#x27;tests-suffix.js&#x27;,
      ];
      let emberCLITree = new ConfigReplace(new UnwatchedDir(__dirname), this._configTree(), {
        configPath: path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;${this.env}.json&#x60;),
        files,

        patterns: this._configReplacePatterns(),
      });

      this._cachedEmberCLITree = new Funnel(emberCLITree, {
        files,
        srcDir: &#x27;/&#x27;,
        destDir: &#x27;/vendor/ember-cli/&#x27;,
        annotation: &#x27;Funnel (ember-cli-tree)&#x27;,
      });
    }

    return this._cachedEmberCLITree;
  }

  /**
    @private
    @method _testAppConfigTree
    @return
  */
  _testAppConfigTree() {
    if (!this._cachedTestAppConfigTree) {
      let files = [&#x27;app-config.js&#x27;];

      let emberCLITree = new ConfigReplace(new UnwatchedDir(__dirname), this._configTree(), {
        configPath: path.join(this.name, &#x27;config&#x27;, &#x27;environments&#x27;, &#x60;test.json&#x60;),
        files,

        patterns: this._configReplacePatterns(),
      });

      this._cachedTestAppConfigTree = new Funnel(emberCLITree, {
        files,
        srcDir: &#x27;/&#x27;,
        destDir: &#x27;/vendor/ember-cli/&#x27;,
        annotation: &#x27;Funnel (test-app-config-tree)&#x27;,
      });
    }

    return this._cachedTestAppConfigTree;
  }

  /**
    Returns the tree for the app and its dependencies

    @private
    @method appAndDependencies
    @return {Tree} Merged tree
  */
  appAndDependencies() {
    let config = this._configTree();
    let templates = this._processedTemplatesTree();

    let srcTree = this._processedSrcTree();
    let trees = [this._processedAppTree(), srcTree, templates].filter(Boolean);

    let app = this.addonPreprocessTree(&#x27;js&#x27;, mergeTrees(
      trees,
      {
        annotation: &#x27;TreeMerger (preprocessedApp &amp; templates)&#x27;,
        overwrite: true,
      }
    ));

    let external = this._processedExternalTree();
    let preprocessedApp = preprocessJs(app, &#x27;/&#x27;, this.name, {
      registry: this.registry,
    });

    let postprocessedApp = this.addonPostprocessTree(&#x27;js&#x27;, preprocessedApp);
    let emberCLITree = this._processedEmberCLITree();

    let sourceTrees = [
      external,
      postprocessedApp,
      config,
      emberCLITree,
    ];

    return mergeTrees(sourceTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (appAndDependencies)&#x27;,
    });
  }

  test() {
    let tests = this.addonPreprocessTree(&#x27;test&#x27;, this._processedTestsTree());
    let preprocessedTests = preprocessJs(tests, &#x27;/tests&#x27;, this.name, {
      registry: this.registry,
    });
    let coreTestTree = this.addonPostprocessTree(&#x27;test&#x27;, preprocessedTests);

    let appTestTree = this.appTests(coreTestTree);
    let testFilesTree = this.testFiles(coreTestTree);

    return mergeTrees([appTestTree, testFilesTree], {
      annotation: &#x27;TreeMerger (test)&#x27;,
    });
  }

  /**
    @private
    @method appTests
  */
  appTests(coreTestTree) {
    let appTestTrees = [].concat(
      this.hinting &amp;&amp; this.lintTestTrees(),
      this._processedEmberCLITree(),
      this._testAppConfigTree(),
      coreTestTree
    ).filter(Boolean);

    appTestTrees = mergeTrees(appTestTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (appTestTrees)&#x27;,
    });

    return this._concatFiles(appTestTrees, {
      inputFiles: [&#x60;${this.name}/tests/**/*.js&#x60;],
      headerFiles: [&#x27;vendor/ember-cli/tests-prefix.js&#x27;],
      footerFiles: [&#x27;vendor/ember-cli/app-config.js&#x27;, &#x27;vendor/ember-cli/tests-suffix.js&#x27;],
      outputFile: this.options.outputPaths.tests.js,
      annotation: &#x27;Concat: App Tests&#x27;,
    });
  }

  /**
    Runs the &#x60;app&#x60;, &#x60;tests&#x60; and &#x60;templates&#x60; trees through the chain of addons that produces lint trees.

    Those lint trees are afterwards funneled into the &#x60;tests&#x60; folder, babel-ified and returned as an array.

    @private
    @method lintTestsTrees
    @return {Array}
   */
  lintTestTrees() {
    let lintTrees = [];

    let appTree = this._filterAppTree();
    if (appTree) {
      let lintedApp = this.addonLintTree(&#x27;app&#x27;, appTree);
      lintedApp = processModulesOnly(new Funnel(lintedApp, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x60;${this.name}/tests/&#x60;,
        annotation: &#x27;Funnel (lint app)&#x27;,
      }), &#x27;Babel: lintTree(app)&#x27;);

      lintTrees.push(lintedApp);
    }

    if (experiments.MODULE_UNIFICATION &amp;&amp; this.trees.src) {
      let lintedSrc = this.addonLintTree(&#x27;src&#x27;, this.trees.src);
      lintedSrc = processModulesOnly(new Funnel(lintedSrc, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x60;${this.name}/tests/src/&#x60;,
        annotation: &#x27;Funnel (lint src)&#x27;,
      }), &#x27;Babel: lintTree(src)&#x27;);

      lintTrees.push(lintedSrc);
    }

    let lintedTests = this.addonLintTree(&#x27;tests&#x27;, this.trees.tests);
    let lintedTemplates = this.addonLintTree(&#x27;templates&#x27;, this._templatesTree());

    lintedTests = processModulesOnly(new Funnel(lintedTests, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}/tests/&#x60;,
      annotation: &#x27;Funnel (lint tests)&#x27;,
    }), &#x27;Babel: lintTree(tests)&#x27;);

    lintedTemplates = processModulesOnly(new Funnel(lintedTemplates, {
      srcDir: &#x27;/&#x27;,
      destDir: &#x60;${this.name}/tests/&#x60;,
      annotation: &#x27;Funnel (lint templates)&#x27;,
    }), &#x27;Babel: lintTree(templates)&#x27;);

    return [lintedTests, lintedTemplates].concat(lintTrees);
  }

  /**
   * @private
   * @method _addonInstalled
   * @param  {String} addonName The name of the addon we are checking to see if it&#x27;s installed
   * @return {Boolean}
   */
  _addonInstalled(addonName) {
    return !!this.registry.availablePlugins[addonName];
  }

  /**
    Returns the tree for javascript files

    @private
    @method javascript
    @return {Tree} Merged tree
  */
  javascript() {
    let applicationJs = this.appAndDependencies();

    let appFilePath = this.options.outputPaths.app.js;
    let vendorFilePath = this.options.outputPaths.vendor.js;

    this._scriptOutputFiles[vendorFilePath].unshift(&#x27;vendor/ember-cli/vendor-prefix.js&#x27;);

    let strategies = [createApplicationJsStrategy({
      name: this.name,
      outputFile: appFilePath,
      sourceMapConfig: this.options.sourcemaps,
      annotation: &#x27;Concat App&#x27;,
    })];
    let importPaths = Object.keys(this._scriptOutputFiles);

    // iterate over the keys and create N strategies
    // to support scenarios like
    // app.import(&#x27;vendor/foobar.js&#x27;, { outputFile: &#x27;assets/baz.js&#x27; });
    importPaths.forEach(importPath =&gt; {
      strategies.push(createVendorJsStrategy({
        files: this._scriptOutputFiles[importPath],
        isMainVendorFile: importPath === vendorFilePath,
        outputFile: importPath,
        sourceMapConfig: this.options.sourcemaps,
        annotation: &#x27;Vendor JS&#x27;,
      }));
    });

    let assembler = new Assembler(applicationJs, {
      annotation: &#x27;Assembler (vendor &amp; appJS)&#x27;,
      strategies,
    });

    return assembler.toTree();
  }

  /**
    Returns the tree for styles

    @private
    @method styles
    @return {Tree} Merged tree for styles
  */
  styles() {
    if (!this._cachedStylesTree) {
      if (existsSync(&#x60;${this._stylesPath}/${this.name}.css&#x60;)) {
        throw new SilentError(&#x60;Style file cannot have the name of the application - ${this.name}&#x60;);
      }

      let addonTrees = this.addonTreesFor(&#x27;styles&#x27;);
      let external = this._processedExternalTree();
      let styles = new Funnel(this.trees.styles, {
        srcDir: &#x27;/&#x27;,
        destDir: &#x27;/app/styles&#x27;,
        annotation: &#x27;Funnel (styles)&#x27;,
      });

      let trees = [external].concat(addonTrees, styles);

      let options = { outputPaths: this.options.outputPaths.app.css };
      options.registry = this.registry;

      let stylesAndVendor = this.addonPreprocessTree(&#x27;css&#x27;, mergeTrees(trees, {
        annotation: &#x27;TreeMerger (stylesAndVendor)&#x27;,
        overwrite: true,
      }));

      let preprocessedStyles = preprocessCss(stylesAndVendor, &#x27;/app/styles&#x27;, &#x27;/assets&#x27;, options);

      let vendorStyles = [];
      for (let outputFile in this._styleOutputFiles) {
        let isMainVendorFile = outputFile === this.options.outputPaths.vendor.css;
        let headerFiles = this._styleOutputFiles[outputFile];
        let inputFiles = isMainVendorFile ? [&#x27;addon-tree-output/**/*.css&#x27;] : [];

        vendorStyles.push(this._concatFiles(stylesAndVendor, {
          headerFiles,
          inputFiles,
          outputFile,
          allowNone: true,
          annotation: &#x60;Concat: Vendor Styles${outputFile}&#x60;,
        }));
      }

      vendorStyles = this.addonPreprocessTree(&#x27;css&#x27;, mergeTrees(vendorStyles, {
        annotation: &#x27;TreeMerger (vendorStyles)&#x27;,
        overwrite: true,
      }));

      if (this.options.minifyCSS.enabled === true) {
        options = this.options.minifyCSS.options || {};
        options.registry = this.registry;
        preprocessedStyles = preprocessMinifyCss(preprocessedStyles, options);
        vendorStyles = preprocessMinifyCss(vendorStyles, options);
      }

      let mergedTrees = mergeTrees([
        preprocessedStyles,
        vendorStyles,
      ], {
        annotation: &#x27;styles&#x27;,
      });

      this._cachedStylesTree = this.addonPostprocessTree(&#x27;css&#x27;, mergedTrees);
    }

    return this._cachedStylesTree;
  }

  /**
    Returns the tree for test files

    @private
    @method testFiles
    @return {Tree} Merged tree for test files
   */
  testFiles(coreTestTree) {
    let testSupportPath = this.options.outputPaths.testSupport.js;

    testSupportPath = testSupportPath.testSupport || testSupportPath;

    let external = this._processedExternalTree();
    let emberCLITree = this._processedEmberCLITree();

    let addonTestSupportTree = mergeTrees(this.addonTreesFor(&#x27;addon-test-support&#x27;), {
      overwrite: true,
      annotation: &#x27;TreeMerger (addon-test-support)&#x27;,
    });

    let finalAddonTestSupportTree = new Funnel(addonTestSupportTree, {
      allowEmpty: true,
      destDir: &#x27;addon-test-support&#x27;,
      annotation: &#x27;Funnel: Addon Test Support&#x27;,
    });

    let headerFiles = [].concat(
      &#x27;vendor/ember-cli/test-support-prefix.js&#x27;,
      this.legacyTestFilesToAppend
    );

    let inputFiles = [&#x27;addon-test-support/**/*.js&#x27;];

    let footerFiles = [&#x27;vendor/ember-cli/test-support-suffix.js&#x27;];

    let baseMergedTree = mergeTrees([emberCLITree, external, coreTestTree, finalAddonTestSupportTree]);
    let testJs = this._concatFiles(baseMergedTree, {
      headerFiles,
      inputFiles,
      footerFiles,
      outputFile: testSupportPath,
      annotation: &#x27;Concat: Test Support JS&#x27;,
      allowNone: true,
    });

    let testemPath = path.join(__dirname, &#x27;testem&#x27;);
    testemPath = path.dirname(testemPath);

    let testemTree = new Funnel(new UnwatchedDir(testemPath), {
      files: [&#x27;testem.js&#x27;],
      srcDir: &#x27;/&#x27;,
      destDir: &#x27;/&#x27;,
      annotation: &#x27;Funnel (testem)&#x27;,
    });

    if (this.options.fingerprint &amp;&amp; this.options.fingerprint.exclude) {
      this.options.fingerprint.exclude.push(&#x27;testem&#x27;);
    }

    let sourceTrees = [
      testemTree,
      testJs,
    ];

    if (this.vendorTestStaticStyles.length &gt; 0) {
      sourceTrees.push(
        this._concatFiles(external, {
          headerFiles: this.vendorTestStaticStyles,
          outputFile: this.options.outputPaths.testSupport.css,
          annotation: &#x27;Concat: Test Support CSS&#x27;,
        })
      );
    }

    return mergeTrees(sourceTrees, {
      overwrite: true,
      annotation: &#x27;TreeMerger (testFiles)&#x27;,
    });
  }

  /**
    Returns the tree for the additional assets which are not in
    one of the default trees.

    @private
    @method otherAssets
    @return {Tree} Merged tree for other assets
   */
  otherAssets() {
    let external = this._processedExternalTree();
    // combine obviously shared funnels.
    let otherAssetTrees = funnelReducer(this.otherAssetPaths).map(options =&gt; {
      options.annotation = &#x60;Funnel
    ${options.srcDir}
    ${options.destDir}
   include:${options.include.length}&#x60;;

      return new Funnel(external, options);
    });

    return mergeTrees(otherAssetTrees, {
      annotation: &#x27;TreeMerger (otherAssetTrees)&#x27;,
    });
  }

  /**
    @public
    @method dependencies
    @return {Object} Alias to the project&#x27;s dependencies function
  */
  dependencies(pkg) {
    return this.project.dependencies(pkg);
  }

  /**
    Imports an asset into the application.

    @public
    @method import
    @param {Object|String} asset Either a path to the asset or an object with environment names and paths as key-value pairs.
    @param {Object} [options] Options object
    @param {String} [options.type=&#x27;vendor&#x27;] Either &#x27;vendor&#x27; or &#x27;test&#x27;
    @param {Boolean} [options.prepend=false] Whether or not this asset should be prepended
    @param {String} [options.destDir] Destination directory, defaults to the name of the directory the asset is in
    @param {String} [options.outputFile] Specifies the output file for given import. Defaults to assets/vendor.{js,css}
    @param {Array} [options.using] Specifies the array of transformations to be done on the asset. Can do an amd shim and/or custom transformation
    */
  import(asset, options) {
    let assetPath = this._getAssetPath(asset);

    if (!assetPath) {
      return;
    }

    options = defaultsDeep(options || {}, {
      type: &#x27;vendor&#x27;,
      prepend: false,
    });

    let match = assetPath.match(/^node_modules\/((@[^/]+\/)?[^/]+)\//);
    if (match !== null) {
      let basedir = options.resolveFrom || this.project.root;
      let name = match[1];
      let _path = path.dirname(resolve.sync(&#x60;${name}/package.json&#x60;, { basedir }));
      this._nodeModules.set(_path, { name, path: _path });
    }

    let directory = path.dirname(assetPath);
    let subdirectory = directory.replace(new RegExp(&#x60;^vendor/|${this.bowerDirectory}|node_modules/&#x60;), &#x27;&#x27;);
    let extension = path.extname(assetPath);

    if (!extension) {
      throw new Error(&#x27;You must pass a file to &#x60;app.import&#x60;. For directories specify them to the constructor under the &#x60;trees&#x60; option.&#x27;);
    }

    this._import(
      assetPath,
      options,
      directory,
      subdirectory,
      extension
    );
  }

  /**
    @private
    @method _import
    @param {String} assetPath
    @param {Object} options
    @param {String} directory
    @param {String} subdirectory
    @param {String} extension
   */
  _import(assetPath, options, directory, subdirectory, extension) {
    // TODO: refactor, this has gotten very messy. Relevant tests: tests/unit/broccoli/ember-app-test.js
    let basename = path.basename(assetPath);

    if (isType(assetPath, &#x27;js&#x27;, { registry: this.registry })) {
      if (options.using) {
        if (!Array.isArray(options.using)) {
          throw new Error(&#x27;You must pass an array of transformations for &#x60;using&#x60; option&#x27;);
        }
        options.using.forEach(entry =&gt; {
          if (!entry.transformation) {
            throw new Error(&#x60;while importing ${assetPath}: each entry in the \&#x60;using\&#x60; list must have a \&#x60;transformation\&#x60; name&#x60;);
          }

          let transformName = entry.transformation;

          if (!this._customTransformsMap.has(transformName)) {
            let availableTransformNames = Array.from(this._customTransformsMap.keys()).join(&#x27;,&#x27;);
            throw new Error(&#x60;while import ${assetPath}: found an unknown transformation name ${transformName}. Available transformNames are: ${availableTransformNames}&#x60;);
          }

          // process options for the transform and update the options
          let customTransforms = this._customTransformsMap.get(transformName);
          customTransforms.options = customTransforms.processOptions(
            assetPath,
            entry,
            customTransforms.options
          );
          customTransforms.files.push(assetPath);
        });
      }

      if (options.type === &#x27;vendor&#x27;) {
        options.outputFile = options.outputFile || this.options.outputPaths.vendor.js;
        addOutputFile(&#x27;firstOneWins&#x27;, this._scriptOutputFiles, assetPath, options);
      } else if (options.type === &#x27;test&#x27;) {
        if (!allowImport(&#x27;firstOneWins&#x27;, this.legacyTestFilesToAppend, assetPath, options)) { return; }
        if (options.prepend) {
          this.legacyTestFilesToAppend.unshift(assetPath);
        } else {
          this.legacyTestFilesToAppend.push(assetPath);
        }
      } else {
        throw new Error(&#x60;You must pass either \&#x60;vendor\&#x60; or \&#x60;test\&#x60; for options.type in your call to \&#x60;app.import\&#x60; for file: ${basename}&#x60;);
      }
    } else if (extension === &#x27;.css&#x27;) {
      if (options.type === &#x27;vendor&#x27;) {
        options.outputFile = options.outputFile || this.options.outputPaths.vendor.css;
        addOutputFile(&#x27;lastOneWins&#x27;, this._styleOutputFiles, assetPath, options);
      } else {
        if (!allowImport(&#x27;lastOneWins&#x27;, this.vendorTestStaticStyles, assetPath, options)) { return; }
        if (options.prepend) {
          this.vendorTestStaticStyles.unshift(assetPath);
        } else {
          this.vendorTestStaticStyles.push(assetPath);
        }
      }
    } else {
      let destDir = options.destDir;
      if (destDir === &#x27;&#x27;) {
        destDir = &#x27;/&#x27;;
      }
      this.otherAssetPaths.push({
        src: directory,
        file: basename,
        dest: destDir || subdirectory,
      });
    }
  }

  /**
    @private
    @method _getAssetPath
    @param {(Object|String)} asset
    @return {(String|undefined)} assetPath
   */
  _getAssetPath(asset) {
    /* @type {String} */
    let assetPath;

    if (typeof asset !== &#x27;object&#x27;) {
      assetPath = asset;
    } else if (this.env in asset) {
      assetPath = asset[this.env];
    } else {
      assetPath = asset.development;
    }

    if (!assetPath) {
      return;
    }

    assetPath = assetPath.split(&#x27;\\&#x27;).join(&#x27;/&#x27;);

    if (assetPath.split(&#x27;/&#x27;).length &lt; 2) {
      console.log(chalk.red(&#x60;Using \&#x60;app.import\&#x60; with a file in the root of \&#x60;vendor/\&#x60; causes a significant performance penalty. Please move \&#x60;${assetPath}\&#x60; into a subdirectory.&#x60;));
    }

    if (/[*,]/.test(assetPath)) {
      throw new Error(&#x60;You must pass a file path (without glob pattern) to \&#x60;app.import\&#x60;.  path was: \&#x60;${assetPath}\&#x60;&#x60;);
    }

    return assetPath;
  }

  /**
    Returns an array of trees for this application

    @private
    @method toArray
    @return {Array} An array of trees
   */
  toArray() {
    let sourceTrees = [
      this.index(),
      this.javascript(),
      this.styles(),
      // undefined when &#x60;experiments.MODULE_UNIFICATION&#x60; is not available
      this._srcAfterStylePreprocessing,
      this.otherAssets(),
      this.publicTree(),
    ].filter(Boolean);

    if (this.tests &amp;&amp; this.trees.tests) {
      sourceTrees = sourceTrees.concat(this.testIndex(), this.test());
    }

    return sourceTrees;
  }

  /**
    Returns the merged tree for this application

    @public
    @method toTree
    @param  {Array} additionalTrees Array of additional trees to merge
    @return {Tree}                  Merged tree for this application
   */
  toTree(additionalTrees) {
    let tree = mergeTrees(this.toArray().concat(additionalTrees || []), {
      overwrite: true,
      annotation: &#x27;TreeMerger (allTrees)&#x27;,
    });

    return this.addonPostprocessTree(&#x27;all&#x27;, tree);
  }

  /**
    Returns the content for a specific type (section) for index.html.

    Currently supported types:
    - &#x27;head&#x27;
    - &#x27;config-module&#x27;
    - &#x27;head-footer&#x27;
    - &#x27;test-header-footer&#x27;
    - &#x27;body-footer&#x27;
    - &#x27;test-body-footer&#x27;

    Addons can also implement this method and could also define additional
    types (eg. &#x27;some-addon-section&#x27;).

    @private
    @method contentFor
    @param  {Object} config Application configuration
    @param  {RegExp} match  Regular expression to match against
    @param  {String} type   Type of content
    @return {String}        The content.
   */
  contentFor(config, match, type) {
    let content = [];

    // This normalizes &#x60;rootURL&#x60; to the value which we use everywhere inside of Ember CLI.
    // This makes sure that the user doesn&#x27;t have to account for it in application code.
    if (&#x27;rootURL&#x27; in config) {
      config.rootURL = calculateRootURL(config);
    }

    switch (type) {
      case &#x27;head&#x27;: this._contentForHead(content, config); break;
      case &#x27;config-module&#x27;: this._contentForConfigModule(content, config); break;
      case &#x27;app-boot&#x27;: this._contentForAppBoot(content, config); break;
      case &#x27;test-body-footer&#x27;: this._contentForTestBodyFooter(content); break;
    }

    content = this.project.addons.reduce((content, addon) =&gt; {
      let addonContent = addon.contentFor ? addon.contentFor(type, config, content) : null;
      if (addonContent) {
        return content.concat(addonContent);
      }

      return content;
    }, content);

    return content.join(&#x27;\n&#x27;);
  }

  /**
    @private
    @method _contentForTestBodyFooter
    @param {Array} content
  */
  _contentForTestBodyFooter(content) {
    content.push(&#x27;&lt;script&gt;Ember.assert(\&#x27;The tests file was not loaded. Make sure your tests index.html includes &quot;assets/tests.js&quot;.\&#x27;, EmberENV.TESTS_FILE_LOADED);&lt;/script&gt;&#x27;);
  }

  /**
    @private
    @method _contentForHead
    @param {Array} content
    @param {Object} config
  */
  _contentForHead(content, config) {
    content.push(calculateBaseTag(config));

    if (this.options.storeConfigInMeta) {
      content.push(&#x60;&lt;meta name=&quot;${config.modulePrefix}/config/environment&quot; content=&quot;${escape(JSON.stringify(config))}&quot; /&gt;&#x60;);
    }
  }

  /**
    @private
    @method _contentForConfigModule
    @param {Array} content
    @param {Object} config
  */
  _contentForConfigModule(content, config) {
    if (this.options.storeConfigInMeta) {
      content.push(&#x60;var prefix = &#x27;${config.modulePrefix}&#x27;;&#x60;);
      content.push(fs.readFileSync(path.join(__dirname, &#x27;app-config-from-meta.js&#x27;)));
    } else {
      content.push(&#x60;var exports = {&#x27;default&#x27;: ${JSON.stringify(config)}};&#x60; +
        &#x60;Object.defineProperty(exports, &#x27;__esModule&#x27;, {value: true});&#x60; +
        &#x60;return exports;&#x60;);
    }
  }

  /**
    @private
    @method _contentForAppBoot
    @param {Array} content
    @param {Object} config
  */
  _contentForAppBoot(content, config) {
    if (this.options.autoRun) {
      let shouldUseSrc = experiments.MODULE_UNIFICATION &amp;&amp; !!this.trees.src;
      let moduleToRequire = &#x60;${config.modulePrefix}/${shouldUseSrc ? &#x27;src/main&#x27; : &#x27;app&#x27;}&#x60;;
      content.push(&#x27;if (!runningTests) {&#x27;);
      content.push(&#x60;  require(&quot;${moduleToRequire}&quot;)[&quot;default&quot;].create(${calculateAppConfig(config)});&#x60;);
      content.push(&#x27;}&#x27;);
    }
  }
}

module.exports = EmberApp;

/*
  Returns the &lt;base&gt; tag for index.html

  @param  {Object} config Application configuration
  @return {String}        Base tag or empty string
 */
function calculateBaseTag(config) {
  let baseURL = cleanBaseURL(config.baseURL);
  let locationType = config.locationType;

  if (locationType === &#x27;hash&#x27;) {
    return &#x27;&#x27;;
  }

  if (baseURL) {
    return &#x60;&lt;base href=&quot;${baseURL}&quot; /&gt;&#x60;;
  } else {
    return &#x27;&#x27;;
  }
}

function calculateRootURL(config) {
  if (config.rootURL === &#x27;&#x27;) {
    return config.rootURL;
  }

  return cleanBaseURL(config.rootURL) || &#x27;&#x27;;
}

function calculateEmberENV(config) {
  return JSON.stringify(config.EmberENV || {});
}

function calculateAppConfig(config) {
  return JSON.stringify(config.APP || {});
}

function calculateModulePrefix(config) {
  return config.modulePrefix;
}

function addOutputFile(strategy, container, assetPath, options) {
  let outputFile = options.outputFile;

  if (!outputFile) {
    throw new Error(&#x27;outputFile is not specified&#x27;);
  }

  if (!container[outputFile]) {
    container[outputFile] = [];
  }
  if (!allowImport(strategy, container[outputFile], assetPath, options)) { return; }

  if (options.prepend) {
    container[outputFile].unshift(assetPath);
  } else {
    container[outputFile].push(assetPath);
  }
}

// In this strategy the last instance of the asset in the array is the one which will be used.
// This applies to CSS where the last asset always &quot;wins&quot; no matter what.
function _lastOneWins(fileList, assetPath, options) {
  let assetIndex = fileList.indexOf(assetPath);

  // Doesn&#x27;t exist in the current fileList. Safe to remove.
  if (assetIndex === -1) { return true; }

  logger.info(&#x60;Highlander Rule: duplicate \&#x60;app.import(${assetPath})\&#x60;. Only including the last by order.&#x60;);

  if (options.prepend) {
    // The existing asset is _already after_ this inclusion and would win.
    // Therefore this branch is a no-op.
    return false;
  } else {
    // The existing asset is _before_ this inclusion and needs to be removed.
    fileList.splice(fileList.indexOf(assetPath), 1);
    return true;
  }
}

// In JS the asset which would be first will win.
// If it is something which includes globals we want those defined as early as
// possible. Any initialization would likely be repeated. Any mutation of global
// state that occurs on initialization is likely _fixed_.
// Any module definitions will be identical except in the scenario where they&#x27;red
// reified to reassignment. This is likely fine.
function _firstOneWins(fileList, assetPath, options) {
  let assetIndex = fileList.indexOf(assetPath);

  // Doesn&#x27;t exist in the current fileList. Safe to remove.
  if (assetIndex === -1) { return true; }

  logger.info(&#x60;Highlander Rule: duplicate \&#x60;app.import(${assetPath})\&#x60;. Only including the first by order.&#x60;);

  if (options.prepend) {
    // The existing asset is _after_ this inclusion and needs to be removed.
    fileList.splice(fileList.indexOf(assetPath), 1);
    return true;
  } else {
    // The existing asset is _already before_ this inclusion and would win.
    // Therefore this branch is a no-op.
    return false;
  }
}

function allowImport(strategy, fileList, assetPath, options) {
  if (strategy === &#x27;firstOneWins&#x27;) {
    // We must find all occurrences and decide what to do with each.
    return _firstOneWins.call(undefined, fileList, assetPath, options);
  } else if (strategy === &#x27;lastOneWins&#x27;) {
    // We can simply use the &quot;last one wins&quot; strategy.
    return _lastOneWins.call(undefined, fileList, assetPath, options);
  } else {
    return true;
  }
}

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
